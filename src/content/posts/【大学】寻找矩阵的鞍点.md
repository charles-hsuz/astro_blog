---
title: 【大学】寻找矩阵的鞍点
tags: 乐学
categories: 刷题笔记
slug: '90563067'
date: 2022-12-24 03:09:04
---

# 【大学】寻找矩阵的鞍点

二维数组中的鞍点，即该位置上的元素是所在行上的最大值，是所在列上的最小值。
二维数组也可能没有鞍点。

### 输入：
第一行为矩阵的行数和列数，从第二行开始，为矩阵本身（假设输入的矩阵只有0和1个鞍点）
### 输出：
输出数组的鞍点，以及鞍点所在的行列号。如果没有则输出“No Point↵”
### 样例：
序号|测试输入| 期待的输出| 额外进程
--------|:-------- |:-----|--------
1  | `3 4↵`<br>`1 3 5 3↵`<br>`2 3 4 1↵`<br>`3 2 6 7↵`|`Point:a[1][2]==4↵`|0
2|`3 4↵`<br>`1 2 3 4↵`<br>`8 4 3 6↵`<br>`9 4 5 1↵`|`No Point↵`|0


### 思路
最直接的方法：分别计算每一行最大的数和每一列最小的数及其位置，再比对如果位置相同，则输出数组的鞍点，以及鞍点所在的行列号，否则输出“No Point↵”
### 代码
{% hideBlock 查看 %}

```c
#include <stdio.h>

int main()
{
	int i, j, m, n, c = 0;
	scanf("%d%d", &i, &j);
	int a[i][j], Max[i], Min[j];
	for (m = 0; m < i; m++)
	{
		for (n = 0; n < j; n++)
		{
			scanf("%d", &a[m][n]);
		}
	}
	for (m = 0; m < i; m++)
	{
		for (n = 0; n < j - 1; n++)
		{
			Max[m] = a[m][n] < a[m][n + 1] ? n + 1 : n;
		}
	}
	for (n = 0; n < j; n++)
	{
		for (m = 0; m < i - 1; m++)
		{
			Min[n] = a[m][n] < a[m + 1][n] ? m : m + 1;
		}
	}
	for (m = 0; m < i; m++)
	{
		if (Min[Max[m]] == m)
		{
			printf("Point:a[%d][%d]==%d\n", m, Max[m], a[m][Max[m]]);
			c++;
		}
	}
	if (!c)
		printf("No Point\n");
}
```
{% endhideBlock %}