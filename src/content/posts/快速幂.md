---
title: 快速幂
categories: 算法教程
slug: 20c47d09
date: 2023-01-05 17:46:59
cover: 'https://picbed-1304952903.cos.ap-beijing.myqcloud.com/pic/blog202302091658477.png'
---

# 快速幂的原理和实现

## 引入

小明最新迷上了信息竞赛……
好吧，不扯淡了，在我们初学编程时一定都做过这样的题目：
**计算a的k次方**
当时我们是怎样做的呢？很简单，只要循环`k`次就可以了，但是这样的做法时间复杂度是`O(k)`的~~(这个OK真的很好笑)~~
如果要算$\,\,a^{10^{10}}\,\,\,\,\,\,$难道要循环1e10次吗？我们还能不能更快呢？

## 原理
 先考虑一种特殊情况，即 $k = 2^m,(m\in Z^+)$ 的情况，比如 $\,a^{64}\,\,$ ？很明显我们可以先算出$\,a^2\,$，然后算出$\,\,a^4\,\,$，……，最后得到$\,\,a^{64}\,\,$:
$$\begin{split}
&a \times a = a^2\\
&a^2 \times a^2 = a^4\\
&a^4 \times a^4 = a^8\\
&a^8 \times a^8 = a^{16}\\
&a^{16} \times a^{16} = a^{32}\\
&a^{32} \times a^{32} = a^{64}\\
\end{split}$$

这样的话我们只要做**6次**乘法，时间复杂度为 `O(log k)`

扩展这种方法，假设我们需要算 $\,\,a^{233}\,\,$ ,我们不难发现 $a^{233} = a^{1}\times a^{8}\times a^{32} \times a^{64} \times a ^{128}$，也即我们只需要算**0 + 3 + 5 + 6 + 7 + 4 = 25次**，相比于朴素算法的**233次**明显减少

那我们如何将形如 $a^k$ 的形式转化为多个指数为2的幂相乘的形式呢？
观察指数的二进制形式，以`233`为例
$(233)_{10} = (11101001)_2$
也即 $233 = 2^8 + 2^7 + 2^6 + 2^5 + 2^3 + 2^0$
而这显然可以通过**位运算**简单的实现

## 代码实现
```cpp
int fast_pow(int a, int k){
    int ans = 1;
    while(k){
        if(k & 1 != 0){
            ans *= a;
        }
        a *= a;
        k >>= 1;
    }
    return ans;
}
```

可以通过表格理解程序的运算过程：

| 循环次数 | `b`        | `a`               | `ans & 1` | `ans`                                               |
| -------- | ---------- | ----------------- | --------- | --------------------------------------------------- |
| 1        | `11101001` | $\,\,a^1\,\,$     | `true`    | $\,\,a^1\,\,$                                       |
| 2        | `1110100`  | $\,\,a^2\,\,$     | `false`   | $\,\,a^1\,\,$                                       |
| 3        | `111010`   | $\,\,a^4\,\,$     | `false`   | $\,\,a^1\,\,$                                       |
| 4        | `11101`    | $\,\,a^8\,\,$     | `true`    | $\,\,a^{1+8}\,\,$                                   |
| 5        | `1110`     | $\,\,a^{16}\,\,$  | `false`   | $\,\,a^{1+8}\,\,$                                   |
| 6        | `111`      | $\,\,a^{32}\,\,$  | `true`    | $\,\,a^{1+8+32}\,\,\,\,\,\,$                        |
| 7        | `11`       | $\,\,a^{64}\,\,$  | `true`    | $\,\,a^{1+8+32+64}\,\,\,\,\,\,\,\,\,\,$             |
| 8        | `1`        | $\,\,a^{128}\,\,$ | `true`    | $\,\,a^{1+8+32+64+128}\,\,\,\,\,\,\,\,\,\,\,\,\,\,$ |
| 9        | `0`        | `N/A`             | `N/A`     | `N/A`                                               |

## 3?
*其实是为了回答这个问题我才写的这篇博客*
所以，我们能不能把2的幂改成3的？
答案是：**可以**
但是更慢，通过上面的推导，我们应该能发现我们之所以能快速将指数`k`分解为2的幂的和的形式，是因为我们的电脑是**二进制**存储数据的，我们可以通过位运算很方便的实现这种分解，如果要利用3的幂，我们首先得得到指数的三进制表示，还得定义三进制的位运算，并且**这些都是通过二进制的运算实现的**，舍本逐末了属于是 🤔


## $a^n \mod m$

```cpp
using ll = long long;
ll fast_pow(ll a, ll b, ll mod){
    ll ans = 1;
    while(b){
        if(b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}
```
PS:若`mod`为64位整数，则应写成如下形式：
```cpp
using ll = long long;
ll Product_mod(ll a, ll b, ll mod){
    ll sum = 0;
    while(b){
        if(b & 1) sum = (sum + a) % mod;
        a = (a + a) % c;
        b >>= 1;
    }
    return sum;
}
ll fast_pow(ll a, ll b, ll mod){
    ll ans = 1;
    while(b){
        if(b & 1) ans = Product_mod(ans, a, mod);
        a = Product_mod(a, a, mod);
        b >>= 1;
    }
    return ans;
}
```
主要是为了防止`爆 long long`，具体原理为：
$$\begin{split}
&a*233 \mod m\\
=\,\,&a*(1+8+32+64+128) \mod m\\
\Rightarrow \,&a * b\mod m = a * \sum_{i=0}^{k-1} b_i*2^i \mod m\\
\end{split}$$
其中$b_i\,\,$表示`b`的二进制第`i`位

## 矩阵快速幂
其实就是把对应的整型换成矩阵而已，需要重载矩阵类的乘法，
为了统一，可以写成模板
```cpp
using ll = long long;
template<typename T>
T fast_pow(T x, ll y){
    T ans = x;
    y --;
    while(y){
        if(y & 1){
            ans = ans * x;
            y >>= 1;
            x = x * x;
        }
        return ans;
    }
}
```
