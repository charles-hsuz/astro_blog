---
title: 拓扑序列
categories: 算法教程
slug: 751ac048
date: 2023-01-10 15:21:13
cover: 'https://picbed-1304952903.cos.ap-beijing.myqcloud.com/pic/blog202302091658477.png'
---
# 拓扑序列
对于一个**有向图**，如果其顶点的一个序列`A`满足：`对于图中的每条有向边<x,y>，x都出现在y之前`。则称`A`为`G`的一个拓扑序列，**拓扑序列不唯一**，**有向无环图一定有拓扑序列**，所以有向无环图也被称为拓扑图。

## 如何求拓扑序列？
首先观察到所有`入度为0的点都可以作为起点(起点必然是入度为0的点)`
那如果我们把这些点删掉呢？会有新的起点，而`起点必然是入度为0的点`，所以显然，我们只需要不断地`找起点`然后`删起点`就可以了

![](https://picbed-1304952903.cos.ap-beijing.myqcloud.com/pic/blog202301101712034.gif)

### 模板题
给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。
请输出一个任意的拓扑序列，若不存在请输出-1.
**输入格式**
第一行两个整数 n 和 m
接下来的 m 行，每行两个是整数 x 和 y，表示存在一条从 x 指向 y 的边
**输出格式**
共一行，如果存在拓扑序列，则输出任意合法的拓扑序列即可，否则输出 -1

{% hideBlock code %}
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int e[N], ne[N], idx;//邻接表存储图
int h[N];
int q[N], hh = 0, tt = -1;//队列保存入度为0的点，也就是能够输出的点，
int n, m;//保存图的点数和边数
int d[N];////保存各个点的入度

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void topsort(){
    for(int i = 1; i <= n; i++){//遍历一遍顶点的入度。
        if(d[i] == 0)//如果入度为 0, 则可以入队列
            q[++tt] = i;
    }
    while(tt >= hh){//循环处理队列中点的
        int a = q[hh++];
        for(int i = h[a]; i != -1; i = ne[i]){//循环删除 a 发出的边
            int b = e[i];//a 有一条边指向b
            d[b]--;//删除边后，b的入度减1
            if(d[b] == 0)//如果b的入度减为 0,则 b 可以输出，入队列
                q[++tt] = b;
        }
    }
    if(tt == n - 1){//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序
        for(int i = 0; i < n; i++){//队列中保存了所有入度为0的点，依次输出
            cout << q[i] << " ";
        }
    }
    else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序
        cout << -1;//输出-1，代表错误
}


int main(){
    cin >> n >> m;//保存点的个数和边的个数
    memset(h, -1, sizeof h);//初始化邻接矩阵
    while (m -- ){//依次读入边
        int a, b;
        cin >> a >> b;
        d[b]++;//顶点b的入度+1
        add(a, b);//添加到邻接矩阵
    }
    topsort();//进行拓扑排序
    return 0;
}
```
因为是数组模拟的队列，所以实际上数据还在，可以直接输出，如果用了stl就要另开一个队列保存答案
{% endhideBlock %}